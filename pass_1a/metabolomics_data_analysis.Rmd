---
title: "BIC metabolomics data analysis"
output:
  pdf_document: 
    number_sections: true
  html_notebook: default
---

In this document we present the joint analysis of the different metabolomics datasets submitted to BIC (currently, as of June 2019). 

For a literature scan on normalization methods see our document: https://docs.google.com/document/d/1M8p5vU9N7JZcRercQoiz02yPCRTjAitB7-t22r2belo/edit?usp=sharing.
Briefly, metabolomics studies usually use quality control samples throughout the project for assessing the batches, and internal standards (spike-in metabolites) for normalization. Notable methods here are RUV and CCMN. Downstream normalization is used to either deal with the heteroscedasticity of the metabolite-level data (e.g., Pareto normalization) or to account for sample-to-sample variation (MSTUS, Quantile, Median, etc.). Some methods rely on reference samples (pools or qc samples). Loess-based methods that compare each sample to the reference can be used for this normalization. 

# Load all datasets

Load the parsed meta-data (from the cloud), required for all analyses presented here.

```{r,results='hide',message=FALSE,warning=FALSE}
system(paste("~/google-cloud-sdk/bin/gsutil",
  "cp gs://bic_data_analysis/pass1a/pheno_dmaqc/merged_dmaqc_data.RData",
  "."))
load("merged_dmaqc_data.RData")
system("rm merged_dmaqc_data.RData")
rownames(merged_dmaqc_data) = as.character(merged_dmaqc_data$viallabel)

# load required libraries
library(ggplot2);library(reshape2);library(gridExtra)
library(corrplot)

# load our helper functions
source("~/Desktop/repos/motrpac/tools/preprocessing_helper_functions.R")
source("~/Desktop/repos/motrpac/tools/gcp_functions.R")
source("~/Desktop/repos/motrpac-bic-norm-qc/norm_pipelines/supervised_normalization_functions.R")
source("~/Desktop/repos/motrpac-bic-norm-qc/norm_pipelines/unsupervised_normalization_functions.R")

merged_dmaqc_data =  load_from_bucket("merged_dmaqc_data.RData",
    "gs://bic_data_analysis/pass1a/pheno_dmaqc/",F)
merged_dmaqc_data = merged_dmaqc_data[[1]]
rownames(merged_dmaqc_data) = as.character(merged_dmaqc_data$viallabel)
merged_dmaqc_data$tissue = merged_dmaqc_data$sampletypedescription
```

Load the data and separate by tissue. Define a dataset as a combination of site, tissue, and platform.

```{r,results='hide',message=FALSE,warning=FALSE,eval=FALSE}
metabolomics_data_bucket = "gs://bic_data_analysis/pass1a/metabolomics/"
rdata_files = get_files_in_bucket(metabolomics_data_bucket)
rdata_files = rdata_files[grepl(".rdata$",rdata_files,ignore.case = T)]
site_names = c("duke","mayo","broad","gtech","umichigan")
for(site in site_names){
  inds = grepl(site,rdata_files,ignore.case = T)
  names(rdata_files)[inds] = site
}
rdata_files = gsub(metabolomics_data_bucket,"",rdata_files)
rdata_objects = sapply(rdata_files,load_from_bucket,
                       bucket=metabolomics_data_bucket,delete=T)
sapply(rdata_objects,names)
newl = list()
for(nn in names(rdata_objects)){
  for(nn2 in names(rdata_objects[[nn]])){
    newl[[nn2]] = rdata_objects[[nn]][[nn2]]
  }
}
rdata_objects = newl

# Separate the datasets by site, tissue, and type (metadata or not)
raw_abundance_datasets =  rdata_objects[grepl("comp",names(rdata_objects))]
names(raw_abundance_datasets) = gsub("_compounds","",names(raw_abundance_datasets))
sample_metadata = rdata_objects[grepl("sampleme",names(rdata_objects))]
names(sample_metadata) = gsub("_samplemeta","",names(sample_metadata))
get_tissue_from_dataset_name<-function(x){return(strsplit(x,split="_")[[1]][2])}
raw_abundance_datasets_tissues = 
  sapply(names(raw_abundance_datasets),get_tissue_from_dataset_name)
get_site_from_dataset_name<-function(x){return(strsplit(x,split="_")[[1]][1])}
raw_abundance_datasets_sites = 
  sapply(names(raw_abundance_datasets),get_site_from_dataset_name)


# Create datasets for the comparison: remove controls, normalize, fold changes
# this is a named list of dataset
# each name has: site,tissue
# each entry has abundance data, row annot data, control data, sample metadata (optional)
# @assumption: last row annotation column in untargeted data is "RT"
# @assumption: last row annotation column in targeted is "SITE_COMP_NAME"
metabolomics_parsed_datasets = list()
for(dataset in names(raw_abundance_datasets)){
  site = raw_abundance_datasets_sites[[dataset]]
  tissue_name = raw_abundance_datasets_tissues[[dataset]]
  is_untargeted = is.element(site,set = c("broad","gtech","umichigan"))
  d = raw_abundance_datasets[[dataset]]
  sample_meta = sample_metadata[[dataset]]
  print(paste(dataset,nrow(sample_meta)))
  if(is_untargeted){
    lastind = which(names(d)=="RT")
  }
  else{
    lastind = which(names(d)=="SITE_COMP_NAME")
  }
  row_annot = d[,1:lastind];d = d[-c(1:lastind)]
  
  print(table(sapply(d,class)))
  d = as.matrix(d) # transform to matrix
  mode(d) = "numeric" # required as some datasets are given in character
  d[is.na(d)] = 0
  d = log(d+1,base=2)
    
  control_columns = !is.element(colnames(d),set=merged_dmaqc_data$viallabel)
  control_data = d[,control_columns]
  d  = d[,!control_columns]
    
  print(paste("excluded rows with zero variance",sum(apply(d,1,sd)==0)))
  rowinds = apply(d,1,sd)>0
  d = d[rowinds,]
  row_annot = row_annot[rowinds,]
  control_data=control_data[rowinds,]
  
  obj_name = paste(site,tissue_name,sep="_")
  obj = list(sample_data=d,control_data=control_data,
             row_annot=row_annot,sample_meta=sample_meta,
             is_untargeted = is_untargeted)
  metabolomics_parsed_datasets[[dataset]] = obj
}

save_to_bucket(metabolomics_parsed_datasets,
               file = "metabolomics_parsed_datasets.RData",
               bucket = "gs://bic_data_analysis/pass1a/metabolomics/")
```

Alternatively load the result from the bucket to save time:
```{r}
metabolomics_parsed_datasets = load_from_bucket(
  file = "metabolomics_parsed_datasets.RData",
  bucket = "gs://bic_data_analysis/pass1a/metabolomics/")[[1]]
```

# Dataset qc and normalization

## Look at the reference correlations

```{r}
ref_corrs = list()
for(nn in names(metabolomics_parsed_datasets)){
  dataset = metabolomics_parsed_datasets[[nn]]
  x = dataset$control_data
  xmeta = dataset$sample_meta
  cnames = colnames(x)
  ctypes = gsub("\\d",replacement = "",cnames)
  ctypes = gsub("_",replacement = "",ctypes)
  names(ctypes) = cnames
  xcorrs = cor(x,method="spearman")
  ctype2cors = list()
  for(ctype in ctypes){
    inds = names(ctypes)[ctypes==ctype]
    ctype2cors[[ctype]] = xcorrs[inds,inds]
  }
  ref_corrs[[nn]] = lapply(ctype2cors,function(x)x[lower.tri(x)])
}

# Create a report from the control data
ref_cor_sum_report = c()
inds_to_plot = names(which(sapply(ref_corrs,length)>0))
for(dataset_name in inds_to_plot){
  currvals = ref_corrs[[dataset_name]]
  corrs_dists = cbind(
    sapply(currvals,mean,na.rm=T),
    sapply(currvals,sd,na.rm=T),
    sapply(currvals,median,na.rm=T)
  )
  colnames(corrs_dists) = c("mean","sd","median")
  corrs_dists = data.frame(corrs_dists)
  corrs_dists = cbind(rownames(corrs_dists),corrs_dists)
  corrs_dists = cbind(dataset_name,corrs_dists)
  ref_cor_sum_report = rbind(ref_cor_sum_report,corrs_dists)
}
rownames(ref_cor_sum_report) = NULL
write.table(ref_cor_sum_report,sep="\t",quote = F)
rownames(ref_cor_sum_report) = paste(ref_cor_sum_report[,1],
       ref_cor_sum_report[,2],sep=":")
ref_cor_sum_report = as.matrix(ref_cor_sum_report[,-c(1:2)])
ref_cor_sum_report = ref_cor_sum_report[!is.na(ref_cor_sum_report[,1]),]
write.table(rownames(ref_cor_sum_report)[ref_cor_sum_report[,1]<0.8],
            row.names = F,quote=F)

inds_to_plot
nn = "broad_liver_pos"
par(mar=c(10,4,4,4))
boxplot(ref_corrs[[nn]],main=nn,las=2,ylim=c(0,1))
nn = "gtech_liver_pos"
par(mar=c(10,4,4,4))
boxplot(ref_corrs[[nn]],main=nn,las=2,ylim=c(0,1))


# # MA plots: differential abundance examination
# colnames(x)
# x = run_quantile_normalization(x)
# library(edgeR)
# ma_plot(x[,24],x[,25])
# cv_mean_plot(x)
```

# Dataset pairwise comparisons

## As a prediction task

```{r,fig.align="center",out.height='60%',out.width='60%',eval=FALSE}
nfolds = 5
prediction_analysis_results = list()
for(nn1 in names(metabolomics_parsed_datasets)){
  print(nn1)
  for(nn2 in names(metabolomics_parsed_datasets)){
    print(nn2)
    y = metabolomics_parsed_datasets[[nn1]]$sample_data
    x = metabolomics_parsed_datasets[[nn2]]$sample_data
    if(is.null(rownames(x))){
      rownames(x) = metabolomics_parsed_datasets[[nn2]]$row_annot[,3]
    }    
    if(is.null(rownames(y))){
      rownames(y) = metabolomics_parsed_datasets[[nn1]]$row_annot[,3]
    }
    
    y_vials = colnames(y)
    bid_y = merged_dmaqc_data[colnames(y),"bid"]
    bid_x = merged_dmaqc_data[colnames(x),"bid"]
    table(is.element(bid_y,set=bid_x))
    colnames(x) = bid_x
    colnames(y) = bid_y
    x = x[,colnames(y)] # make x in the same order as y
    x = t(as.matrix(x))
    y = t(as.matrix(y))
    
    if(ncol(y)>1000){next}
    
    cov_cols = c("animal.registration.sex",
             "acute.test.weight",
             "acute.test.distance",
             "animal.key.timepoint")
    covs = merged_dmaqc_data[y_vials,cov_cols]
    
    # Run the regressions
    folds = sample(rep(1:nfolds,(1+nrow(x)/nfolds)))[1:nrow(x)]
    numFeatures = min(ncol(x),2000)
    preds = c();real=c()
    for(i in 1:ncol(y)){
      y_i = y[,1]
      i_preds = c();i_real=c()
      for(j in 1:nfolds){
        print(j)
        tr_x = x[folds!=j,]
        tr_yi = y_i[folds!=j]
        te_x = x[folds==j,]
        te_y = y_i[folds==j]
        # random forest
        # model = randomForest(tr_yi,x=tr_x,ntree = 20)
        # te_preds = predict(model,newdata = te_x)
        model = feature_selection_wrapper(tr_x,tr_yi,
                   coeff_of_var,randomForest,
                   topK = numFeatures,ntree=50)
        te_preds = predict(model,newdata = te_x)
        i_preds = c(i_preds,te_preds)
        i_real = c(i_real,te_y)
      }
      preds = cbind(preds,i_preds)
      real = cbind(real,i_real)
    }
    currname = paste(nn1,nn2,sep=";")
    prediction_analysis_results[[currname]] = list(
      preds = preds,real=real
    )
  }
}
names(prediction_analysis_results)

cov_prediction_analysis_results = list()
for(nn1 in names(metabolomics_parsed_datasets)){
  print(nn1)
  y = metabolomics_parsed_datasets[[nn1]]$sample_data
  y_vials = colnames(y)
  bid_y = merged_dmaqc_data[colnames(y),"bid"]
  colnames(y) = bid_y
  y = t(as.matrix(y))
  if(ncol(y)>1000){next}
  cov_cols = c("animal.registration.sex",
             "acute.test.weight",
             "acute.test.distance",
             "animal.key.timepoint")
  covs = merged_dmaqc_data[y_vials,cov_cols]
  x = covs
  
  # Run the regressions
  folds = sample(rep(1:nfolds,(1+nrow(x)/nfolds)))[1:nrow(x)]
  numFeatures = min(ncol(x),2000)
  preds = c();real=c()
  for(i in 1:ncol(y)){
    y_i = y[,1]
    i_preds = c();i_real=c()
    for(j in 1:nfolds){
      print(j)
      tr_x = x[folds!=j,]
      tr_yi = y_i[folds!=j]
      te_x = x[folds==j,]
      te_y = y_i[folds==j]
      # random forest
      model = randomForest(tr_yi,x=tr_x,ntree = 20)
      te_preds = predict(model,newdata = te_x)
      i_preds = c(i_preds,te_preds)
      i_real = c(i_real,te_y)
    }
    preds = cbind(preds,i_preds)
    real = cbind(real,i_real)
  }
  cov_prediction_analysis_results[[nn1]] = list(
      preds = preds,real=real
    )
}

results_metrics = c()
for(nn in names(prediction_analysis_results)){
  preds = prediction_analysis_results[[nn]]$preds
  real = prediction_analysis_results[[nn]]$real
  rhos1 = diag(cor(preds,real))
  rhos2 = diag(cor(preds,real,method="spearman"))
  SEs = (preds-real)^2
  mse = mean(SEs)
  normSEs = SEs / apply(real,2,sd)
  curr_scores = c(mean(rhos1),mean(rhos2),min(rhos1),min(rhos2),
                  mse,mean(normSEs))
  names(curr_scores) = c("mean_rho","mean_spearman_rho","min_rho","min_spearman_rho",
                         "MSE","mean MSE/SD")
  results_metrics = rbind(results_metrics,
                          curr_scores)
  rownames(results_metrics)[nrow(results_metrics)] = nn
}

cov_results_metrics = c()
for(nn in names(cov_prediction_analysis_results)){
  preds = cov_prediction_analysis_results[[nn]]$preds
  real = cov_prediction_analysis_results[[nn]]$real
  rhos1 = diag(cor(preds,real))
  rhos2 = diag(cor(preds,real,method="spearman"))
  SEs = (preds-real)^2
  mse = mean(SEs)
  normSEs = SEs / apply(real,2,sd)
  curr_scores = c(mean(rhos1),mean(rhos2),min(rhos1),min(rhos2),
                  mse,mean(normSEs))
  names(curr_scores) = c("mean_rho","mean_spearman_rho","min_rho","min_spearman_rho",
                         "MSE","mean MSE/SD")
  cov_results_metrics = rbind(cov_results_metrics,
                          curr_scores)
  rownames(cov_results_metrics)[nrow(cov_results_metrics)] = nn
}

# Some boxplots
pred_targets = sapply(names(prediction_analysis_results),function(x)
  strsplit(x,split = ";")[[1]][1])
target = "duke_liver_tar"
curr_res = unique(results_metrics[pred_targets == target,])
rownames(curr_res) = gsub(target,"",rownames(curr_res))
rownames(curr_res) = gsub(";","",rownames(curr_res))
rownames(curr_res)[rownames(curr_res)==""] = target
cov_baseline = cov_results_metrics[target,]

par(mar = c(8,4,2,2))
cols = rep("blue",nrow(curr_res))
cols[rownames(curr_res)==target] = "black"
plt = barplot(curr_res[,4],beside = T,xaxt="n",legend=F,
              ylab="Min rho (Spearman)",
              ylim = c(0.5,1),xpd=F,col=cols,
              main = target)
text(plt, par("usr")[3], labels = rownames(curr_res), 
     srt = 45, adj = c(1.1,1.1), xpd = T, cex=0.6)
abline(h=cov_baseline[4],lty=2,lwd=2,col="red")

par(mar = c(8,4,2,2))
plt = barplot(curr_res[,6],beside = T,xaxt="n",legend=F,
              ylab="Mean standardized SE",xpd=F,
              main = target,col=cols)
text(plt, par("usr")[3], labels = rownames(curr_res), 
     srt = 45, adj = c(1.1,1.1), xpd = T, cex=0.6)
abline(h=cov_baseline[6],lty=2,lwd=2,col="red")

preds = c();real=c()
for(j in 1:nfolds){
  tr_x = x[folds!=j,]
  tr_y = y[folds!=j,]
  te_x = x[folds==j,]
  te_y = y[folds==j,]
  model = MTL_wrapper(tr_x,tr_y,type="Regression", Regularization="L21")
  te_preds = predict(model,te_x)
  real = rbind(real,te_y)
  preds = rbind(preds,te_preds)
}
diag(cor(preds,real))

# Using PLS regression
# library(pls)
# pls_model = plsr(y~x,ncomp = 5,validation="LOO")
# eval = MSEP(pls_model)
# 
# y_pca = prcomp(y)
# plot(y_pca)
# explained_var = y_pca$sdev^2/sum(y_pca$sdev^2)
# y_pca_matrix = y_pca$x[,1:10]
# 
# # regress out sex, weight
# 
# get_explained_variance_using_PCA(x,y)
# x = apply(x,2,regress_out,covs=covs)
# y = apply(y,2,regress_out,covs=covs)
# get_explained_variance_using_PCA(x,y)


```

## Comparison of covariance matrices

```{r}

CV <-function(x){
  return(sd(x)/mean(x))
}

# Get all correlation and covariance matrices
y = metabolomics_parsed_datasets[[1]]$sample_data # anchor all datasets by these ids
y_vials = colnames(y)
bid_y = as.character(merged_dmaqc_data[colnames(y),"bid"])
cov_cols = c("animal.registration.sex",
             "acute.test.weight",
             "acute.test.distance")
covs = merged_dmaqc_data[y_vials,cov_cols]

cov_matrices = list()
cor_matrices = list()
for(nn in names(metabolomics_parsed_datasets)){
  x = metabolomics_parsed_datasets[[nn]]$sample_data
  bid_x = as.character(merged_dmaqc_data[colnames(x),"bid"])
  print(sum(!is.element(bid_y,set=bid_x))) # should be zero
  colnames(x) = bid_x
  x = x[,bid_y]
  # x = apply(x,1,regress_out,covs=covs)
  # x = t(x)
  # cvs = apply(x,1,CV)
  # print(table(cvs>0.5))
  # x = x[cvs>0.5,]
  # pcax = t(prcomp(t(x),scale. = F)$x[,1:10])
  cov_matrices[[nn]] = cov(x)
  cor_matrices[[nn]] = cor(x)
}
sapply(cor_matrices,dim)
library('evolqg');library(corrplot)
mantel_tests= MantelCor(cor_matrices)
mcors= MatrixCor(cor_matrices)
mcors = as.matrix(forceSymmetric(mcors,uplo="L"))
mantel_tests = as.matrix(
  forceSymmetric(mantel_tests$probabilities,uplo = "L"))
# diag(mantel_tests)=0
ord = corrplot(t(mcors),order="hclust")
ord = rownames(ord)
corrplot(mcors[ord,ord],p.mat=mantel_tests[ord,ord],
         insig = "label_sig",method="shade",
         sig.level = c(.0001, .001, .01),
         pch.cex = .9, pch.col = "black")
# rs_res = RandomSkewers(cor_matrices)
# corrplot(rs_res$correlations,
#          p.mat=mantel_tests$probabilities,type="lower",
#          insig = "label_sig",method="shade",
#          sig.level = c(.0001, .001, .01),
#          pch.cex = .9, pch.col = "black",tl.cex=0.6)

library(psych)

r1 = cor_matrices[[1]]
r2 = cor_matrices[[8]]
cor(r1[lower.tri(r1)],r2[lower.tri(r2)])
mantel_tests[1,8]
mantel_tests[8,1]

threshold_comp = apply_function_on_pairs(cor_matrices,
          function(x,y)sum(x>0.7&y>0.7))
corrplot(threshold_comp,is.corr = F,order="hclust")

threshold_comp = apply_function_on_pairs(cor_matrices,
         function(x,y)mean(diag(cor(x,y))))
corrplot(threshold_comp,is.corr = F,order="hclust")

```

# Integrarion with RNAseq

```{r}
rnaseq_data_for_difftests = load_from_bucket(
  "rnaseq_data_for_difftests.RData",
  "gs://bic_data_analysis/pass1a/rnaseq/"
)[[1]]
met_vs_rnaseq_cors = c()
for(nn in names(rnaseq_data_for_difftests)){
  d = rnaseq_data_for_difftests[[nn]]$fpkms
  covs = rnaseq_data_for_difftests[[nn]]$dmaqc_meta[,cov_cols]
  
  cvs = apply(d,1,CV)
  print(table(cvs>0.25))
  x = d[cvs>0.25,]
  # x = apply(x,1,regress_out,covs=covs)
  # x = t(x)
  
  bid_x = sapply(colnames(x),substr,1,5)
  print(sum(!is.element(bid_y,set=bid_x))) # should be zero
  colnames(x) = bid_x
  x = x[,bid_y]
  
  curr_cors = cor(x)
  v = c()
  for(nn2 in names(cor_matrices)){
    v[nn2] = MatrixCor(curr_cors,cor_matrices[[nn2]])
  }
  met_vs_rnaseq_cors = rbind(met_vs_rnaseq_cors,v)
  rownames(met_vs_rnaseq_cors)[nrow(met_vs_rnaseq_cors)] = nn
}
library(gplots)
heatmap.2(t(met_vs_rnaseq_cors),
          trace="none",scale=NULL,mar=c(15,15),
          key.xlab = "Correlation",
          col=redblue(200), breaks=seq(-1,1,0.01))

```

# Looking at metabolite overlap

```{r,fig.align="center",out.height='50%',out.width='80%',message=FALSE,warning=FALSE}
metabolite_sets = list()
for(nn in names(metabolomics_parsed_datasets)){
  an = metabolomics_parsed_datasets[[nn]]$row_annot
  name_cols = colnames(an)[grepl("_name",colnames(an),ignore.case = T)]
  metabolite_sets[[nn]] = unique(tolower(an[,name_cols[1]]))
}
overlap_matrix = apply_function_on_pairs(metabolite_sets,
                                         function(x,y)length(intersect(x,y)))
corrplot(log(overlap_matrix+1,10),is.corr = F)


site_cor_comparison = apply_function_on_pairs(
  metabolomics_parsed_datasets,
  compare_two_met_sites,print_progress = T,
  merged_dmaqc_data = merged_dmaqc_data,samplesize=500
)

site_cor_comparison[is.na(site_cor_comparison)]=0
corrplot(site_cor_comparison,order="hclust")

compare_two_met_sites<-function(x,y,merged_dmaqc_data,samplesize=100,...){
  an_x = x$row_annot
  name_colsx = colnames(an_x)[grepl("_name",colnames(an_x),ignore.case = T)]
  an_y = y$row_annot
  name_colsy = colnames(an_y)[grepl("_name",colnames(an_y),ignore.case = T)]
  
  names_x = as.character(an_x[,name_colsx[1]])
  names_y = as.character(an_y[,name_colsy[1]])
  shared = intersect(names_x,names_y)
  shared = setdiff(shared,c(NA,""))
  
  mx = x$sample_data
  my = y$sample_data
  
  if(any(table(names_x)>1)){
    mx = apply(mx,2,function(x,y)tapply(x,INDEX=y,FUN=mean,na.rm=T),y=names_x)
  }
  else{
    rownames(mx) = as.character(names_x)
  }
  if(any(table(names_y)>1)){
    my = apply(my,2,function(x,y)tapply(x,INDEX=y,FUN=mean,na.rm=T),y=names_y)
  }
  else{
    rownames(my) = as.character(names_y)
  }
  
  bid_x = as.character(merged_dmaqc_data[colnames(mx),"bid"])
  bid_y = as.character(merged_dmaqc_data[colnames(my),"bid"])
  if(sum(!is.element(bid_y,set=bid_x))>0){
    stop("BIDs do not match between x and y")
  } # should be zero
  colnames(mx) = bid_x
  colnames(my) = bid_y
  if(length(shared)>samplesize){
    shared = sample(shared)[1:samplesize]
  }
  mx = mx[shared,bid_y]
  my = my[shared,]
  mx = as.matrix(mx);my = as.matrix(my)
  if(nrow(mx)<2){return(NA)}
  # print("####")
  # print(dim(mx))
  # print("####")
  # print(dim(my))
  if(length(shared)<=100){
    corrs = diag(cor(t(mx),t(my)))
  }
  else{
    corrs = c()
    for(i in 1:nrow(mx)){
      # print(mean(mx[i,]))
      corrs[rownames(mx)[i]] = cor(mx[i,],my[i,])
    }
  }
  return(mean(corrs))
}

```

# Differential abundance analysis












