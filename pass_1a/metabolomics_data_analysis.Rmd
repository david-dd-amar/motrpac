---
title: "BIC metabolomics data analysis"
output:
  pdf_document: 
    number_sections: true
  html_notebook: default
---

In this document we present the joint analysis of the different metabolomics datasets submitted to BIC (currently, as of June 2019). We rely on the following resources for metabolomics-specific issues (in addition to the MOP):
Gorrochategui et al. (https://www.sciencedirect.com/science/article/pii/S0165993616300425), section 3.2.5 on data intensity normalization. Li et al. (https://academic.oup.com/nar/article/45/W1/W162/3835313) for description of normalization tools. 

Briefly, metabolic data are senitive to drift and batch effects, especially in long-term studies. To cope with these issues, studies usually use quality control samples throughout the project for assessing the batches, and internal standards and/or quality control metabolites for normalization. Notable methods here are RUV and CCMN. Downstream normalization is used to either deal with the heteroscedasticity of the metabolite-level data (e.g., Pareto normalization) or to account for sample-to-sample variation (MSTUS, Quantile, Median, etc.).

Load the parsed meta-data (from the cloud), required for all analyses presented here.

```{r}
system(paste("~/google-cloud-sdk/bin/gsutil",
             "cp gs://bic_data_analysis/pass1a/pheno_dmaqc/merged_dmaqc_data.RData",
             "."))
load("merged_dmaqc_data.RData")
system("rm merged_dmaqc_data.RData")
rownames(merged_dmaqc_data) = as.character(merged_dmaqc_data$viallabel)

# load required libraries
library(ggplot2);library(reshape2);library(gridExtra)

# load our helper functions
source("~/Desktop/repos/motrpac/tools/preprocessing_helper_functions.R")
source("~/Desktop/repos/motrpac/tools/gcp_functions.R")
```

# Load all datasets

```{r}
metabolomics_data_bucket = "gs://bic_data_analysis/pass1a/metabolomics/"
rdata_files = get_files_in_bucket(metabolomics_data_bucket)
rdata_files = rdata_files[grepl(".rdata$",rdata_files,ignore.case = T)]
site_names = c("duke","mayo","broad","gtech")
for(site in site_names){
  inds = grepl(site,rdata_files,ignore.case = T)
  names(rdata_files)[inds] = site
}
rdata_files = gsub(metabolomics_data_bucket,"",rdata_files)
rdata_objects = sapply(rdata_files,load_from_bucket,
                       bucket=metabolomics_data_bucket,delete=T)
sapply(rdata_objects,names)
newl = list()
for(nn in names(rdata_objects)){
  for(nn2 in names(rdata_objects[[nn]])){
    newl[[nn2]] = rdata_objects[[nn]][[nn2]]
  }
}
rdata_objects = newl

# Separate the datasets by site, tissue, and type (metadata or not)
raw_abundance_datasets =  rdata_objects[grepl("comp",names(rdata_objects))]
names(raw_abundance_datasets) = gsub("_compounds","",names(raw_abundance_datasets))
sample_metadata = rdata_objects[grepl("sampleme",names(rdata_objects))]
names(sample_metadata) = gsub("_samplemeta","",names(sample_metadata))
get_tissue_from_dataset_name<-function(x){return(strsplit(x,split="_")[[1]][2])}
raw_abundance_datasets_tissues = 
  sapply(names(raw_abundance_datasets),get_tissue_from_dataset_name)
get_site_from_dataset_name<-function(x){return(strsplit(x,split="_")[[1]][1])}
raw_abundance_datasets_sites = 
  sapply(names(raw_abundance_datasets),get_site_from_dataset_name)


# Create datasets for the comparison: remove controls, normalize, fold changes
# this is a named list of dataset
# each name has: site,tissue
# each entry has abundance data, row annot data, control data, sample metadata (optional)
metabolomics_parsed_datasets = list()
for(dataset in names(raw_abundance_datasets)){
  site = raw_abundance_datasets_sites[[dataset]]
  tissue_name = raw_abundance_datasets_tissues[[dataset]]
  is_untargeted = is.element(site,set = c("broad","gtech"))
  d = raw_abundance_datasets[[dataset]]
  sample_meta = sample_metadata[[dataset]]
  if(is_untargeted){
    row_annot = d[,1:8];d = d[-c(1:8)]
  }
  else{
    row_annot = d[,1:2];d = d[-c(1:2)]
  }
    
  d[is.na(d)] = 0
  d = log(d+1,base=2)
    
  control_columns = !is.element(colnames(d),set=merged_dmaqc_data$viallabel)
  control_data = d[,control_columns]
  d  = d[,!control_columns]
    
  # if site is broad then quantile normalize
  if(is_untargeted){
    d = run_quantile_normalization(d)
  }
    
  print(paste("excluded rows with zero variance",sum(apply(d,1,sd)==0)))
  rowinds = apply(d,1,sd)>0
  d = d[rowinds,]
  row_annot = row_annot[rowinds,]
  control_data=control_data[rowinds,]
    
  # # Compute fold change data vs. the mean pre treatment
  # curr_time_points = merged_dmaqc_data[colnames(d),"animal.key.timepoint"]
  # curr_controls = merged_dmaqc_data[colnames(d),"animal.key.is_control"]
  # raw_group_info = merged_dmaqc_data[colnames(d),"animal.key.anirandgroup"]
  # curr_sex = merged_dmaqc_data[colnames(d),"animal.registration.sex"]
    
  obj_name = paste(site,tissue_name,sep="_")
  obj = list(sample_data=d,control_data=control_data,
             row_annot=row_annot,sample_meta=sample_meta)
  metabolomics_parsed_datasets[[dataset]] = obj
}

save_to_bucket(metabolomics_parsed_datasets,
               file = "metabolomics_parsed_datasets.RData",
               bucket = "gs://bic_data_analysis/pass1a/metabolomics/")
```

# Pairwise comparisons

## Using simple correlations

## Using PLS2 regression

```{r,fig.align="center",out.height='60%',out.width='60%',eval=FALSE}
y = metabolomics_parsed_datasets$duke_muscle$sample_data
x = metabolomics_parsed_datasets$broad_muscle$sample_data

y_vials = colnames(y)
bid_y = merged_dmaqc_data[colnames(y),"bid"]
bid_x = merged_dmaqc_data[colnames(x),"bid"]
table(is.element(bid_y,set=bid_x))
colnames(x) = bid_x
colnames(y) = bid_y
x = x[,colnames(y)] # make x in the same order as y
x = t(as.matrix(x))
y = t(as.matrix(y))

library(pls)
pls_model = plsr(y~x,ncomp = 5,validation="LOO")
eval = MSEP(pls_model)

y_pca = prcomp(y)
plot(y_pca)
explained_var = y_pca$sdev^2/sum(y_pca$sdev^2)
y_pca_matrix = y_pca$x[,1:10]

# regress out sex, weight
cov_cols = c("animal.registration.sex",
             "acute.test.weight",
             "acute.test.distance")
covs = merged_dmaqc_data[y_vials,cov_cols]

get_explained_variance_using_PCA(x,y)
x = apply(x,2,regress_out,covs=covs)
y = apply(y,2,regress_out,covs=covs)
get_explained_variance_using_PCA(x,y)


```

## Comparison of covariance matrices

```{r}

CV <-function(x){
  return(sd(x)/mean(x))
}

# Get all correlation and covariance matrices
y = metabolomics_parsed_datasets[[1]]$sample_data # anchor all datasets by these ids
y_vials = colnames(y)
bid_y = as.character(merged_dmaqc_data[colnames(y),"bid"])
cov_cols = c("animal.registration.sex",
             "acute.test.weight",
             "acute.test.distance")
covs = merged_dmaqc_data[y_vials,cov_cols]

cov_matrices = list()
cor_matrices = list()
for(nn in names(metabolomics_parsed_datasets)){
  x = metabolomics_parsed_datasets[[nn]]$sample_data
  bid_x = as.character(merged_dmaqc_data[colnames(x),"bid"])
  print(sum(!is.element(bid_y,set=bid_x))) # should be zero
  colnames(x) = bid_x
  x = x[,bid_y]
  # x = apply(x,1,regress_out,covs=covs)
  # x = t(x)
  # cvs = apply(x,1,CV)
  # print(table(cvs>0.5))
  # x = x[cvs>0.5,]
  # pcax = t(prcomp(t(x),scale. = F)$x[,1:10])
  cov_matrices[[nn]] = cov(x)
  cor_matrices[[nn]] = cor(x)
}
sapply(cor_matrices,dim)
library('evolqg');library(corrplot)
mantel_tests= MantelCor(cor_matrices)
mcors= MatrixCor(cor_matrices)
mcors = as.matrix(forceSymmetric(mcors,uplo="L"))
mantel_tests = as.matrix(
  forceSymmetric(mantel_tests$probabilities,uplo = "L"))
# diag(mantel_tests)=0
ord = corrplot(t(mcors),order="hclust")
ord = rownames(ord)
corrplot(mcors[ord,ord],p.mat=mantel_tests[ord,ord],
         insig = "label_sig",method="shade",
         sig.level = c(.0001, .001, .01),
         pch.cex = .9, pch.col = "black")
# rs_res = RandomSkewers(cor_matrices)
# corrplot(rs_res$correlations,
#          p.mat=mantel_tests$probabilities,type="lower",
#          insig = "label_sig",method="shade",
#          sig.level = c(.0001, .001, .01),
#          pch.cex = .9, pch.col = "black",tl.cex=0.6)

library(psych)

r1 = cor_matrices[[1]]
r2 = cor_matrices[[8]]
cor(r1[lower.tri(r1)],r2[lower.tri(r2)])
mantel_tests[1,8]
mantel_tests[8,1]

threshold_comp = apply_function_on_pairs(cor_matrices,
          function(x,y)sum(x>0.7&y>0.7))
corrplot(threshold_comp,is.corr = F,order="hclust")

threshold_comp = apply_function_on_pairs(cor_matrices,
         function(x,y)mean(diag(cor(x,y))))
corrplot(threshold_comp,is.corr = F,order="hclust")

```

# Integrarion with RNAseq

```{r}
rnaseq_data_for_difftests = load_from_bucket(
  "rnaseq_data_for_difftests.RData",
  "gs://bic_data_analysis/pass1a/rnaseq/"
)[[1]]
met_vs_rnaseq_cors = c()
for(nn in names(rnaseq_data_for_difftests)){
  d = rnaseq_data_for_difftests[[nn]]$fpkms
  covs = rnaseq_data_for_difftests[[nn]]$dmaqc_meta[,cov_cols]
  
  cvs = apply(d,1,CV)
  print(table(cvs>0.25))
  x = d[cvs>0.25,]
  # x = apply(x,1,regress_out,covs=covs)
  # x = t(x)
  
  bid_x = sapply(colnames(x),substr,1,5)
  print(sum(!is.element(bid_y,set=bid_x))) # should be zero
  colnames(x) = bid_x
  x = x[,bid_y]
  
  curr_cors = cor(x)
  v = c()
  for(nn2 in names(cor_matrices)){
    v[nn2] = MatrixCor(curr_cors,cor_matrices[[nn2]])
  }
  met_vs_rnaseq_cors = rbind(met_vs_rnaseq_cors,v)
  rownames(met_vs_rnaseq_cors)[nrow(met_vs_rnaseq_cors)] = nn
}
library(gplots)
heatmap.2(t(met_vs_rnaseq_cors),
          trace="none",scale=NULL,mar=c(15,15),
          key.xlab = "Correlation",
          col=redblue(200), breaks=seq(-1,1,0.01))

```

# Looking at metabolite overlap

```{r,fig.align="center",out.height='50%',out.width='80%',message=FALSE,warning=FALSE}
metabolite_sets = list()
for(nn in names(metabolomics_parsed_datasets)){
  an = metabolomics_parsed_datasets[[nn]]$row_annot
  name_cols = colnames(an)[grepl("_name",colnames(an),ignore.case = T)]
  metabolite_sets[[nn]] = unique(tolower(an[,name_cols[1]]))
}
overlap_matrix = apply_function_on_pairs(metabolite_sets,
                                         function(x,y)length(intersect(x,y)))
corrplot(log(overlap_matrix+1,10),is.corr = F)


site_cor_comparison = apply_function_on_pairs(
  metabolomics_parsed_datasets,
  compare_two_met_sites,print_progress = T,
  merged_dmaqc_data = merged_dmaqc_data,samplesize=500
)

site_cor_comparison[is.na(site_cor_comparison)]=0
corrplot(site_cor_comparison,order="hclust")

compare_two_met_sites<-function(x,y,merged_dmaqc_data,samplesize=100,...){
  an_x = x$row_annot
  name_colsx = colnames(an_x)[grepl("_name",colnames(an_x),ignore.case = T)]
  an_y = y$row_annot
  name_colsy = colnames(an_y)[grepl("_name",colnames(an_y),ignore.case = T)]
  
  names_x = as.character(an_x[,name_colsx[1]])
  names_y = as.character(an_y[,name_colsy[1]])
  shared = intersect(names_x,names_y)
  shared = setdiff(shared,c(NA,""))
  
  mx = x$sample_data
  my = y$sample_data
  
  if(any(table(names_x)>1)){
    mx = apply(mx,2,function(x,y)tapply(x,INDEX=y,FUN=mean,na.rm=T),y=names_x)
  }
  else{
    rownames(mx) = as.character(names_x)
  }
  if(any(table(names_y)>1)){
    my = apply(my,2,function(x,y)tapply(x,INDEX=y,FUN=mean,na.rm=T),y=names_y)
  }
  else{
    rownames(my) = as.character(names_y)
  }
  
  bid_x = as.character(merged_dmaqc_data[colnames(mx),"bid"])
  bid_y = as.character(merged_dmaqc_data[colnames(my),"bid"])
  if(sum(!is.element(bid_y,set=bid_x))>0){
    stop("BIDs do not match between x and y")
  } # should be zero
  colnames(mx) = bid_x
  colnames(my) = bid_y
  if(length(shared)>samplesize){
    shared = sample(shared)[1:samplesize]
  }
  mx = mx[shared,bid_y]
  my = my[shared,]
  mx = as.matrix(mx);my = as.matrix(my)
  if(nrow(mx)<2){return(NA)}
  # print("####")
  # print(dim(mx))
  # print("####")
  # print(dim(my))
  if(length(shared)<=100){
    corrs = diag(cor(t(mx),t(my)))
  }
  else{
    corrs = c()
    for(i in 1:nrow(mx)){
      # print(mean(mx[i,]))
      corrs[rownames(mx)[i]] = cor(mx[i,],my[i,])
    }
  }
  return(mean(corrs))
}

```

# Differential abundance analysis












